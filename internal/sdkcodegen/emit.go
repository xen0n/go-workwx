package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
)

type emitter interface {
	EmitCode(spec *hir) error
	Finalize() error
}

type goEmitter struct {
	Sink io.Writer

	buf bytes.Buffer
}

var _ emitter = (*goEmitter)(nil)

func (e *goEmitter) e(format string, a ...interface{}) (n int, err error) {
	return fmt.Fprintf(&e.buf, format, a...)
}

func (e *goEmitter) EmitCode(spec *hir) error {
	e.e("// Code generated by sdkcodegen; DO NOT EDIT.\n")
	e.e("\n")
	e.e("package workwx\n")
	e.e("\n")

	for i := range spec.topics {
		err := e.emitTopic(&spec.topics[i])
		if err != nil {
			return err
		}
	}

	return nil
}

func (e *goEmitter) Finalize() error {
	result, err := format.Source(e.buf.Bytes())
	if err != nil {
		return err
	}

	_, err = e.Sink.Write(result)
	if err != nil {
		return err
	}

	return nil
}

func (e *goEmitter) emitTopic(x *topic) error {
	for i := range x.models {
		err := e.emitModel(&x.models[i])
		if err != nil {
			return err
		}
		e.e("\n")
	}
	return nil
}

func (e *goEmitter) emitModel(x *apiModel) error {
	// TODO: normalize ident according to visibility
	ident := x.ident

	if len(x.doc) > 0 {
		// TODO: multi-line docstring
		e.e("// %s %s\n", ident, x.doc)
	}
	e.e("type %s struct {\n", ident)

	for i := range x.fields {
		err := e.emitModelField(&x.fields[i])
		if err != nil {
			return err
		}
	}

	e.e("}\n")

	golangSnippets := x.inlineCodeSections["go"]
	if len(golangSnippets) > 0 {
		e.e("\n")

		for _, s := range golangSnippets {
			e.e("%s\n", s)
		}

		e.e("\n")
	}

	return nil
}

func (e *goEmitter) emitModelField(x *apiModelField) error {
	// TODO: normalize ident according to visibility
	ident := x.ident

	if len(x.doc) > 0 {
		// TODO: multi-line docstring
		e.e("// %s %s\n", ident, x.doc)
	}
	e.e("%s %s", ident, x.typ)

	if len(x.tags) > 0 {
		e.e("`")

		isFirst := true
		for k, v := range x.tags {
			if isFirst {
				isFirst = false
			} else {
				e.e(" ")
			}

			e.e("%s:\"%s\"", k, v)
		}

		e.e("`")
	}
	e.e("\n")

	return nil
}
